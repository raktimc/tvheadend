#!/usr/bin/python
# -*- coding: utf-8 -*-
# 
# Copyright (C) 2013  Alex Revetchi
#
# mcast is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import urllib
import urllib2
import json
import time
from optparse import OptionParser

optParser = OptionParser()
optParser.add_option('--host',  type='string', default='localhost', help='tvheadend web admin address, default: localhost')
optParser.add_option('--port',  type='int', default=9981, help='tvheadend web admin port, default: 9981')
optParser.add_option('--sid',   type='int', default=None, help='SID of the service')
optParser.add_option('--msid',   type='string', default=None, help='Multicast group ID')
optParser.add_option('--mip',   type='string', default=None, help='Multicast IP used for service muticasting')
optParser.add_option('--mport', type='int', default=None, help='Multicast port used for service muticasting')
optParser.add_option('--mux',   type='string', default='pass', help='Mux type: [pass, raw, ..], default: pass')
optParser.add_option('--file',  type='string', default=None, dest='fname', help='CSV file containing a list of service SIDs and multicast IP and port')

(opts,args) = optParser.parse_args()

def execApiRequest(path):
	global opts
	urllib2.urlopen('http://%s:%i%s' % (opts.host, opts.port, path)).read()

def execApiRequestJ(path):
	global opts
	response = urllib2.urlopen('http://%s:%i%s' % (opts.host, opts.port, path)).read()
	return json.loads(response)

def kill(sid):
	cnns = execApiRequestJ('/api/status/connections')
	if cnns and 'entries' in cnns:
		for e in cnns['entries']:
			if e['type'] == 'UDP-MULTICAST' and e['user'] == sid:
				print 'Closing multicast group %s' % e['user']
				execApiRequestJ('/api/connections/cancel?'+ urllib.urlencode({'id': e['id']}))
				break
def killall():
	cnns = execApiRequestJ('/api/status/connections')
	if cnns and 'entries' in cnns:
		ids = [str(e['id']) for e in cnns['entries'] if e['type'] == 'UDP-MULTICAST']
		ents = '[' + ','.join(ids) + ']'
		if len(ents) <= 2:
			print "No multicast connections found to stop..."
			return
		print "Closing %d multicasts..." % len(ids)
		execApiRequestJ('/api/connections/cancel?'+ urllib.urlencode({'id': ents}))

	time.sleep(0.5)
	cnns = execApiRequestJ('/api/status/connections')
	if cnns and 'entries' in cnns:
		ids = [ e['id'] for e in cnns['entries'] if e['type'] == 'UDP-MULTICAST']
		if len(ids):
			print 'Failed to stop %i multicast connections ids: %s' % (len(ids), str(ids))
		else:
			print 'All multicast connections stopped...'

def check(address, port, cnns=None):
	uname = '%s:%i' % (address, port)
	if not cnns:
		cnns = execApiRequestJ('/api/status/connections')
	if cnns and 'entries' in cnns:
		unames = [ e['user'] for e in cnns['entries'] if e['type'] == 'UDP-MULTICAST' ]
		return uname in unames
	return None 

def startFromFile(fileName, mux='pass', sid=None, msid=None):
	services = execApiRequestJ('/api/service/list')
	cnns = execApiRequestJ('/api/status/connections')
	f = open(fileName, 'r')
	i=0
	for line in f:
		i+=1
		mcast_opts = [mopts.strip() for mopts in line.rstrip('\r\n').split(',')]
		if mcast_opts and len(mcast_opts) > 5:
			sid_opt = int(float(mcast_opts[4]))
			if sid and sid != sid_opt:
				if msid and msid == mcast_opts[5]:
					print "Requested sid and multicast address mismatch in: %s:%d" % (fileName, i)
				continue
			if msid and msid != mcast_opts[5]:
				if sid and sid == sid_opt:
					print "Requested sid and multicast address mismatch in: %s:%d" % (fileName, i)
				continue
			ipport = mcast_opts[5].split(':')
			start(sid_opt, ipport[0], int(ipport[1]), 'pass', services, cnns)

def start(sid, address, port, mux, services=None, cnns=None):
	busy = check(address, port, cnns)
	if busy or busy == None:
		print 'Supplied address: %s and port: %i already in use, or could not check...' % (address, port)
		return
	if not services:
		services = execApiRequestJ('/api/service/list')
	if not services or not 'entries' in services:
		print 'Could not fetch service list from the server...'
		return

	enabled = False
	uuid = None
	for svc in services['entries']:
		for param in svc['params']:
			if param['id'] == 'enabled' and bool(param['value']):
				enabled = True
			if param['id'] == 'sid' and sid == int(param['value']):
				uuid = svc['id'].encode("utf-8")
		if uuid:
			if enabled:
				print 'Starting %s sid: %i ...' % (svc['text'].encode("utf-8"), sid)
				execApiRequest(('/stream/mcast/%s?' % uuid) + urllib.urlencode({'address': address, 'port': port, 'mux': mux}))
				time.sleep(0.5)
#				print json.dumps(svc, indent=4)
			else:
				print 'Service with sid: %i is disabled...' % sid
			return

try:
	for action in args:
		if action == 'kill':
			if opts.msid:
				kill(opts.msid)
			else:
				print 'Connection ID missing...'
		elif action == 'killall':
			killall()
		elif action == 'start':
			if opts.fname:
				startFromFile(opts.fname, opts.mux, opts.sid, opts.msid)
			elif not opts.sid or not opts.mip or not opts.mport:
				print 'Not enough parameters provided...'
			else:
				start(opts.sid, opts.mip, opts.mport, opts.mux)	
except Exception as e:
	print 'Failed: %s' % str(e)

exit(0)
